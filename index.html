<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Electrify Chicago - Emission Visualizer</title>
    
    <!-- Libraries -->
    <script src="https://d3js.org/d3.v7.min.js"></script> 
    <script src="https://unpkg.com/papaparse@latest/papaparse.min.js"></script>
    
    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/SVRUfmW7o8SUwESrCSx=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20n6a9c42z65Z50Qo0v/R7sR5U8i7n0s7f1lM2+fM3E=" crossorigin=""></script>

    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #000;
            overflow: hidden;
        }

        /* --- Layers --- */
        #app-container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        .view-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #video {
            object-fit: cover;
            z-index: 1;
            background: #111;
        }

        #map {
            z-index: 2;
            background: #eee;
        }

        /* State Classes */
        .hidden-layer {
            opacity: 0;
            pointer-events: none;
            z-index: 0 !important;
        }
        .active-layer {
            opacity: 1;
            pointer-events: auto;
            z-index: 2 !important;
        }

        /* --- UI Overlays --- */
        
        /* Top Bar: Centered to avoid map controls */
        #top-overlay {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%); /* Center horizontally */
            width: auto;
            max-width: 60%; /* Prevent it from hitting the sides */
            z-index: 20;
            display: flex;
            justify-content: center;
        }

        #building-link {
            background-color: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 8px 16px;
            border-radius: 20px;
            text-decoration: none;
            font-size: 0.9rem; /* Smaller font */
            font-weight: 500;
            
            /* Text Truncation logic */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: block;
            max-width: 100%;
            
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
            transition: background-color 0.2s, border-color 0.2s;
        }

        #building-link:hover {
            border-color: #10b981;
        }

        /* Toggle Button (Top Right) */
        #view-toggle-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 21;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: none;
            background-color: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
        }
        
        /* Compact Bottom Widget */
        #ghg-intensity-widget {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px; /* Reduced from 80px for a tighter look */
            background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0) 100%); /* Smoother fade */
            z-index: 20;
            padding-bottom: 10px; /* Safe area for bottom of screen */
            pointer-events: none; 
        }

        #loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            z-index: 30;
            text-align: center;
            pointer-events: none;
            background: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border-radius: 8px;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <!-- View 1: Camera -->
        <video id="video" class="view-layer active-layer" autoplay playsinline muted></video>

        <!-- View 2: Map -->
        <div id="map" class="view-layer hidden-layer"></div>

        <!-- UI: Top Overlay (Centered) -->
        <div id="top-overlay">
            <a id="building-link" href="#" target="_blank">Locating...</a>
        </div>

        <!-- UI: View Toggle -->
        <button id="view-toggle-btn" title="Toggle Camera/Map">üó∫Ô∏è</button>

        <!-- UI: Bottom Widget -->
        <div id="ghg-intensity-widget"></div>

        <!-- Loading Status -->
        <div id="loading-indicator">Loading Data...</div>
    </div>

    <script>
    // --- DOM Elements ---
    const videoElement = document.getElementById('video');
    const mapElement = document.getElementById('map');
    const buildingLink = document.getElementById('building-link');
    const toggleBtn = document.getElementById('view-toggle-btn');
    const widgetContainer = document.getElementById('ghg-intensity-widget');
    const loadingIndicator = document.getElementById('loading-indicator');

    // --- Constants & State ---
    const CSV_FILE_PATH = 'https://raw.githubusercontent.com/vkoves/electrify-chicago/refs/heads/main/src/data/dist/building-benchmarks.csv'; 
    const IPLOCATE_API = 'https://iplocate.io/api/lookup'; 
    
    let allCsvData = [];
    let map;
    let markersLayer;
    // Storing references to markers to highlight them later
    const buildingMarkersMap = new Map();
    let ghgIntensityStats = {};
    
    // View State
    let isCameraMode = true;
    let cameraStream = null;

    // --- 1. View Controller & Battery Saving Logic ---

    function toggleView() {
        if (isCameraMode) {
            activateMap();
        } else {
            activateCamera();
        }
    }

    function activateMap() {
        isCameraMode = false;
        // UI Updates
        videoElement.classList.replace('active-layer', 'hidden-layer');
        mapElement.classList.replace('hidden-layer', 'active-layer');
        toggleBtn.textContent = "üì∑"; 
        
        // Stop Camera to save battery
        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
            cameraStream = null;
        }

        // Refresh map layout
        setTimeout(() => { map.invalidateSize(); }, 300);
    }

    async function activateCamera() {
        // Start Camera
        const success = await startCameraStream();
        
        if (success) {
            isCameraMode = true;
            // UI Updates
            mapElement.classList.replace('active-layer', 'hidden-layer');
            videoElement.classList.replace('hidden-layer', 'active-layer');
            toggleBtn.textContent = "üó∫Ô∏è";
        } else {
            alert("Camera access denied or unavailable.");
            activateMap();
        }
    }

    async function startCameraStream() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { facingMode: 'environment' } 
            });
            videoElement.srcObject = stream;
            cameraStream = stream;
            return true;
        } catch (err) {
            console.error("Camera Error:", err);
            return false;
        }
    }

    toggleBtn.addEventListener('click', toggleView);

    // Initial Camera Start
    startCameraStream().then(success => {
        if(!success) activateMap();
    });


    // --- 2. Data & Statistics Logic ---

    function calculateGhgStats(data) {
        const validIntensities = data
            .map(d => parseFloat(d.GHGIntensity))
            .filter(v => !isNaN(v) && v > 0);

        if (validIntensities.length === 0) return;

        const sortedIntensities = [...validIntensities].sort(d3.ascending);
        
        ghgIntensityStats = {
            min: 0,
            max: d3.max(validIntensities),
            // Grading boundaries (Lower intensity = Better grade)
            boundaryA: d3.quantile(sortedIntensities, 0.20), 
            boundaryB: d3.quantile(sortedIntensities, 0.40), 
            boundaryC: d3.quantile(sortedIntensities, 0.60), 
            boundaryD: d3.quantile(sortedIntensities, 0.80),
            visMax: d3.quantile(sortedIntensities, 0.95) || d3.max(validIntensities)
        };
    }

    function getColor(value) {
        if (!ghgIntensityStats.max) return '#6b7280';
        if (value <= ghgIntensityStats.boundaryA) return '#10b981'; // Green
        if (value <= ghgIntensityStats.boundaryB) return '#facc15'; // Yellow
        if (value <= ghgIntensityStats.boundaryC) return '#fb923c'; // Orange
        return '#ef4444'; // Red
    }

    // --- 3. Compact Visualization Widget ---

    function renderIntensityWidget(currentIntensity) {
        const container = d3.select("#ghg-intensity-widget");
        container.html(""); 

        if (!ghgIntensityStats.max || isNaN(currentIntensity)) {
            // Adjusted padding for the smaller height
            container.html("<div style='color:#ccc; font-size:0.8rem; text-align:center; padding-top:25px'>Select a building</div>");
            return;
        }

        const rect = widgetContainer.getBoundingClientRect();
        // Tighter margins
        const margin = { top: 10, right: 15, bottom: 5, left: 15 };
        const width = rect.width - margin.left - margin.right;
        const height = rect.height - margin.top - margin.bottom;
        const domainMax = ghgIntensityStats.visMax;

        const svg = container.append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const x = d3.scaleLinear().domain([0, domainMax]).range([0, width]);

        // Zones
        const zones = [
            { start: 0, end: ghgIntensityStats.boundaryA, color: '#10b981' },
            { start: ghgIntensityStats.boundaryA, end: ghgIntensityStats.boundaryB, color: '#facc15' },
            { start: ghgIntensityStats.boundaryB, end: ghgIntensityStats.boundaryC, color: '#fb923c' },
            { start: ghgIntensityStats.boundaryC, end: domainMax, color: '#ef4444' }
        ];

        // 1. Title (Moved higher up, y=0 relative to margin)
        svg.append("text")
            .attr("x", 0)
            .attr("y", 0)
            .attr("fill", "#9ca3af")
            .attr("font-size", "9px") // Slightly smaller
            .style("text-transform", "uppercase")
            .text("GHG Intensity (kg CO2e/sq ft)");

        // 2. Color Bar (Moved up to y=8)
        const barY = 8;
        const barHeight = 6;
        
        svg.selectAll(".zone")
            .data(zones)
            .enter().append("rect")
            .attr("x", d => x(d.start))
            .attr("y", barY) 
            .attr("width", d => Math.max(0, x(Math.min(d.end, domainMax)) - x(d.start)))
            .attr("height", barHeight)
            .attr("fill", d => d.color)
            .attr("opacity", 0.6)
            .attr("rx", 2);

        // 3. Ticks (Just small lines below bar)
        const xAxis = d3.axisBottom(x).ticks(5).tickSize(3).tickFormat("");
        svg.append("g")
            .attr("transform", `translate(0, ${barY + barHeight})`)
            .call(xAxis)
            .select(".domain").remove();

        // Indicator Logic
        const cx = x(Math.min(currentIntensity, domainMax));
        const cColor = getColor(currentIntensity);

        // 4. Needle (Centered on the bar)
        svg.append("line")
            .attr("x1", cx).attr("x2", cx)
            .attr("y1", barY - 2).attr("y2", barY + barHeight + 2)
            .attr("stroke", "#fff")
            .attr("stroke-width", 2)
            .attr("filter", "drop-shadow(0 0 1px black)");

        // 5. Value Text (Aligned to the right, vertically centered with title)
        svg.append("text")
            .attr("x", width)
            .attr("y", 5) // Aligned with the top area
            .attr("text-anchor", "end")
            .attr("fill", cColor)
            .attr("font-weight", "bold")
            .attr("font-size", "18px") // Larger font for readability
            .style("text-shadow", "0 1px 2px rgba(0,0,0,0.8)")
            .text(currentIntensity.toFixed(1));
    }

    // --- 4. Utility Functions ---

    function toSlug(text) {
        if (!text) return '';
        return String(text).toLowerCase().trim()
            .replace(/[^a-z0-9\s-]/g, '')
            .replace(/[\s-]+/g, '-');
    }

    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = (lat2 - lat1) * (Math.PI / 180);
        const dLon = (lon2 - lon1) * (Math.PI / 180);
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) * 
                  Math.sin(dLon / 2) * Math.sin(dLon / 2);
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    // --- 5. Map & Data Logic ---

    function initializeMap() {
        // Removed { zoomControl: false } to restore default Top-Left position
        map = L.map('map').setView([41.8781, -87.6298], 13); 
        
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
            maxZoom: 19,
            attribution: '&copy; OpenStreetMap &copy; CARTO'
        }).addTo(map);
        
        markersLayer = L.layerGroup().addTo(map);
    }
    initializeMap();

    function updateUI(entry) {
        loadingIndicator.style.display = 'none';

        // Update Top Link
        if (entry.PropertyName) {
            const slug = toSlug(entry.PropertyName);
            buildingLink.textContent = entry.PropertyName;
            buildingLink.href = `https://electrifychicago.net/building/${slug}`;
            buildingLink.style.pointerEvents = 'auto';
            buildingLink.style.opacity = '1';
        } else {
            buildingLink.textContent = "Unknown Building";
            buildingLink.style.pointerEvents = 'none';
            buildingLink.style.opacity = '0.7';
        }

        // Update Widget
        const intensity = parseFloat(entry.GHGIntensity);
        renderIntensityWidget(intensity);
    }

    function populateMap(userLat, userLon) {
        markersLayer.clearLayers();
        buildingMarkersMap.clear();

        // User Location Marker (Blue)
        L.circleMarker([userLat, userLon], { 
            radius: 8, color: '#ffffff', weight: 2, fillColor: '#2563eb', fillOpacity: 1 
        }).addTo(markersLayer).bindPopup("Your Location");

        if (!allCsvData.length) return;

        // Process ALL buildings
        // We calc distance just to find the closest one for initial selection, 
        // but we render all of them.
        let closestEntry = null;
        let minDistance = Infinity;

        const bounds = new L.LatLngBounds();
        bounds.extend([userLat, userLon]);

        allCsvData.forEach((entry, index) => {
            const lat = parseFloat(entry.Latitude);
            const lon = parseFloat(entry.Longitude);
            
            if (isNaN(lat) || isNaN(lon)) return;

            const dist = calculateDistance(userLat, userLon, lat, lon);
            if (dist < minDistance) {
                minDistance = dist;
                closestEntry = entry;
            }

            // Color Coding
            const intensity = parseFloat(entry.GHGIntensity);
            const color = getColor(intensity);

            const marker = L.circleMarker([lat, lon], {
                radius: 5, // Smaller radius for density
                weight: 1,
                color: color,
                fillColor: color,
                fillOpacity: 0.8
            }).addTo(markersLayer);

            // Interaction
            marker.on('click', () => {
                // Reset previous highlight (simplistic approach: reset all is too slow, 
                // in a real app we'd track the 'selected' marker)
                
                // Just Set UI
                updateUI(entry);
                
                // Visual feedback
                marker.bringToFront();
                marker.setStyle({ radius: 10, weight: 2, color: '#fff' });
                setTimeout(() => { marker.setStyle({ radius: 5, weight: 1, color: color }); }, 2000);
            });

            bounds.extend([lat, lon]);
        });

        // Auto-select closest
        if (closestEntry) {
            updateUI(closestEntry);
        }
        
        // Initial zoom to fit user + immediate surroundings (not necessarily all bounds)
        map.setView([userLat, userLon], 15);
    }

    // --- 6. Initialization Flow ---

    function loadCsvData() {
        Papa.parse(CSV_FILE_PATH, {
            download: true, header: true, dynamicTyping: true,
            complete: function(results) {
                allCsvData = results.data.filter(d => d.Latitude && !isNaN(parseFloat(d.Latitude)));
                calculateGhgStats(allCsvData);
                getGeolocation();
            },
            error: (err) => {
                console.error("CSV Error:", err);
                loadingIndicator.textContent = "Error loading data";
            }
        });
    }

    function getGeolocation() {
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (pos) => populateMap(pos.coords.latitude, pos.coords.longitude),
                (err) => fallbackToIP()
            );
        } else {
            fallbackToIP();
        }
    }

    function fallbackToIP() {
        fetch(IPLOCATE_API)
            .then(res => res.json())
            .then(data => {
                if(data.latitude) populateMap(data.latitude, data.longitude);
            })
            .catch(err => console.error("IP Geo Error", err));
    }

    // Start Application
    loadCsvData();

    </script>
</body>
</html>
